# FUNCTIONS: SCOPE & FLEXIBILITY
--------------------------------

* The Scope of Things
---------------------
Take a look at the program below. We have a void function named favorite_animal() and main() with a few statements inside.

#include <iostream>
 
std::string sea_animal = "manatee";
 
void favorite_animal(std::string best_animal) {
 
  std::string animal = best_animal;
  std::cout << "Best animal: " << animal << "\n";
 
}
 
int main() {
 
  favorite_animal("jaguar");
 
  std::cout << sea_animal << "\n";
  std::cout << animal << "\n";
 
}

When this program is compiled and executed, sea_animal will print, but animal won’t. Why do you think that’s the case?

Scope is the region of code that can access or view a given element.

	. Variables defined in global scope are accessible throughout the program.

	. Variables defined in a function have local scope and are only accessible inside the function.

sea_animal was defined in global scope at the top of the program, outside of main(). So sea_animal is defined everywhere in the program.

Because animal was only defined within favorite_animal() and not returned, it is not accessible to the rest of the program.

main.cpp
--------
#include <iostream>

void enter_code(int passcode) {

  std::string secret_knowledge = "https://content.codecademy.com/courses/regex/onyourexcitingjourneylearningtocodeyouwillfindthis.gif";
  
  if (passcode == 0310) {
    
    std::cout << secret_knowledge << "\n";
    
  } else {
    
    std::cout << "Sorry, incorrect!\n";
    
  }
}

int main() {
    
  enter_code(0310);
  
}

==================================================================================================================================================================

* Multi-File Programs
---------------------
Programs can grow quickly. With a few functions, you can declare the function above main() and then you can define the function below main() like this:

#include <iostream>
 
// Declaration at the top:
void eat();
 
int main() {
 
  eat();
 
}
 
// Definition at the bottom:
void eat() {
 
  std::cout << "nom nom nom\n";
 
}

But this isn’t ideal when your code gets longer; it’s common to use the same function in more than one .cpp file.

To make your code cleaner and more modular, you can move the function definitions over to another specialized .cpp file (e.g., my_functions.cpp), leaving a list of declarations above 
main().

But files, like functions, have scope. So, how does the main() program know about the function definitions?

Before your program even compiles, it links together any files you list in your compilation statement into a single executable:

g++ main.cpp my_functions.cpp

And voila! Your program knows the function definitions.

main.cpp
--------
#include <iostream>
#include <cmath>

// Add declarations here:
double average(double num1, double num2);
int tenth_power(int num);
bool is_palindrome(std::string text);

int main() {
  
  std::cout << is_palindrome("racecar") << "\n";
  std::cout << tenth_power(3) << "\n";
  std::cout << average(8.0, 19.0) << "\n";
  
}

my_functions.cpp
----------------
#include <iostream>
#include <cmath>

// Add definitions here:
double average(double num1, double num2) {
  return (num1 + num2) / 2;
}

int tenth_power(int num) {
  return pow(num, 10);
}

bool is_palindrome(std::string text) {
  std::string reversed_text = "";
  
  for (int i = text.size() - 1; i >= 0; i--) {
    reversed_text += text[i];
  }
  
  if (reversed_text == text) {
    return true;
  }
  
  return false;
}

==================================================================================================================================================================

* Getting a Header Yourself
---------------------------
If your program keeps growing, you may have to scroll through many declarations before you see main(). That doesn’t seem like the best way to do things. Plus you don’t want to keep 
declaring the same functions over and over for different files — making changes would be incredibly tiresome!

Well, you can take those function declarations and move them all over to a header file, another file — usually with the same name as the file with all of the function definitions — with 
the extension .hpp or .h. For example, if your function definitions are in my_functions.cpp, the corresponding header file would be my_functions.hpp or my_functions.h.

So how do you bring everything from a header file into scope for another file? Do you just link the header in the compilation statement like you did with the second .cpp file?

As it turns out, with headers, you can just add #include "my_functions.hpp" to the very top of main.cpp:

#include "my_functions.hpp"

Boom! This line pastes in everything from my_functions.hpp. Now you have access to all of the function declarations you stowed away in your header.

main.cpp
--------
#include <iostream>
#include "fns.hpp"

int main() {
  
  std::cout << is_palindrome("noon") << "\n";
  std::cout << tenth_power(4) << "\n";
  std::cout << average(4.0, 7.0) << "\n";
  
}

==================================================================================================================================================================

* How to Get Your Functions Inline
----------------------------------
Once you set foot in the wild of C++ development, you may encounter the term “inline functions” with a couple different meanings. An inline function is a function definition, usually in a 
header file, qualified by inline like this:

inline 
void eat() {
 
  std::cout << "nom nom\n";
 
}

Using inline advises the compiler to insert the function’s body where the function call is, which sometimes helps with execution speed (and sometimes hinders execution speed). If you do 
use it, we recommend testing how it affects the execution speed of your program. The bottom line is inline is something you’ll probably encounter, but may never use.

However, you will sometimes also hear about “inline functions” that are just member functions (i.e. functions inside of classes — we’ll explain classes later) which have been defined and 
declared in a single line in a header file because the function body is so short:

// cookie_functions.hpp
 
// eat() belongs to the Cookie class:
void Cookie::eat() {std::cout << "nom nom\n";} 

Please note that you should ALWAYS add the inline keyword if you are inlining functions in a header (unless you are dealing with member functions, which are automatically inlined for 
you).

main.cpp
--------
#include <iostream>
#include <chrono>

#include "night.hpp"

int main() {
  
  // Measure time taken for goodnight1():
  std::chrono::high_resolution_clock::time_point start = std::chrono::high_resolution_clock::now();

  std::cout << goodnight1("tulip");
  
  std::chrono::high_resolution_clock::time_point end = std::chrono::high_resolution_clock::now();
  std::chrono::duration<double, std::milli> time_span = end - start;

  // Print time taken for goodnight1():
  std::cout << "Time taken for goodnight1(): " << time_span.count() << " milliseconds.\n\n";
  
  
  std::cout << goodnight2("eraser", "ivy");
  
}

night.hpp
---------
inline
std::string goodnight1(std::string thing1) {
  return "Goodnight, " + thing1 + ".\n";
}
std::string goodnight2(std::string thing1, std::string thing2);

night.cpp
---------
#include <string>

std::string goodnight2(std::string thing1, std::string thing2) {
  return "Goodnight, " + thing1 + " jumping over the " + thing2 + ".\n";
}

==================================================================================================================================================================































































