# FUNCTIONS
-----------

* The Function of Functions
---------------------------
As a programmer, you will find yourself reusing the same blocks of code over and over throughout your program. In times like these, you can turn to functions.

Also known as a method or procedure, a function is a named group of code statements that accomplish something together, a bit like a factory machine.

There are some great reasons to use functions in your code:

A single line can make all that code fire off instead of a whole bunch of lines.
You can build DRY (Don’t Repeat Yourself) code, reusing the code you already wrote.
Functions help make your code flexible and modular, meaning you can group your code more easily by task.
In fact, every C++ program has at least one function. “Hold on,” you may be thinking, “I’ve written some C++ programs, but I haven’t written any functions yet!”

Well, as it happens, main() is a function that you’ve already used! And you’ll understand it a bit more as you learn how functions work.

main.cpp
--------
#include <iostream>

int main() {
  
  // Conduct IT support
  std::string on_off_attempt;
  std::cout << "Hello. IT.\n";
  std::cout << "Have you tried turning it off and on again? y/n\n";
  std::cin >> on_off_attempt;
  
  // Check in with Jen
  std::cout << "Oh hi Jen!\n";
  
  // Conduct IT support again...
  std::cout << "Hello. IT.\n";
  std::cout << "Have you tried turning it off and on again? y/n\n";
  std::cin >> on_off_attempt;

  // Check in with Roy
  std::cout << "You stole the stress machine? But that's stealing!\n";
  
  // Conduct IT support yet again...zzzz...
  std::cout << "Hello. IT.\n";
  std::cout << "Have you tried turning it off and on again? y/n\n";
  std::cin >> on_off_attempt;
  
}

==================================================================================================================================================================

* Built-in Functions
--------------------
Before we learn how to create functions, let’s go over some built-in functions…

C++ comes chock-full of functions that are already created as part of the standard library. But how do we access this hidden hoard of helpful functions? We gain access to various functions by including headers like <cmath> or <string>.

In fact, you may already have used a couple functions without even knowing it! With the following header:

#include <cmath>

We gain the power to call sqrt() to find the square root of any number.

Wait, “call” sqrt()?

Calling a function is how we get a function to take action. To call a basic function, we just need the function name followed by a pair of parentheses like sqrt(9). For example:

std::cout << sqrt(9) << "\n";
 
// This would output 3

main.cpp
--------
#include <iostream>

int main() {
  
  // This seeds the random number generator:
  srand (time(NULL));
  
  // Use rand() below to initialize the_amazing_random_number
  int the_amazing_random_number = rand() % 7;
  
  std::cout << the_amazing_random_number;
}

==================================================================================================================================================================

* Declare & Define
------------------
Often, built-in functions aren’t enough to tackle the wide array of programming challenges out there. But never fear: you can write your own functions too!

A C++ function is comprised of two distinct parts:

	. Declaration: this includes the function’s name, what the return type is, and any parameters (if the function will accept input values, known as arguments).

	. Definition: also known as the body of the function, this contains the instructions for what the function is supposed to do.

This is the overall structure:

return_type function_name( any, parameters, you, have ) {
 
   // Code block here
 
   return output_if_there_is_any;
 
}

This is what it might look like with real code:

void make_sandwich() {
 
  std::cout << "bread\n";
  std::cout << "egg\n";
  std::cout << "cheese\n";
  std::cout << "avocado\n";
  std::cout << "bread\n";
 
}

==================================================================================================================================================================

* Void — The Point of No Return
-------------------------------
Let’s build a simple function with no input and no output. We can do that?

Enter the void specifier, which is added in the function declaration before the function name. A void function, also known as a subroutine, has no return value, making it ideally suited 
for situations where you just want to print stuff to the terminal.

For example:

void animal_chat() {
 
  std::string fav, pet;
 
  std::cout << "What's your favorite animal?\n";
  std::cin >> fav;
 
  std::cout << "Do you have a " << fav << " as a pet? y/n\n";
  std::cin >> pet;
 
  if (pet == "y") {
 
    std::cout << "How lucky you have a " << fav << " as a pet!\n";
 
  } else {
 
    std::cout << "That's too bad.\n";
 
  }
 
}

The above chat program is built to capture user responses and print to the terminal without returning any values.

main.cpp
--------
#include <iostream>

// Define oscar_wilde_quote() below:
void oscar_wilde_quote() {
  std::cout << "The highest, as the lowest, form of criticism is a mode of autobiography.";
}

int main() {
  
  // Call your function here:
  oscar_wilde_quote();
  
}

==================================================================================================================================================================

* Return Types — Beyond the Void
--------------------------------
When you do in fact want your function to return something and pass information back to the rest of your program, C++ has you covered. Just like there are many variable types, there are many different return types for functions.

A function can return most data types we’ve covered, including double, int, bool, char, std::string, and std::vector.

std::string always_blue() {
 
  return "blue!\n";
 
}

Note: The return statement is the last line of code that a function will execute. For example:

std::string always_blue() {
 
  return "blue!\n";
 
  std::cout << "Returned blue!";
 
}

The final line will not execute because a value has already been returned. So "Returned blue!" won’t be printed to the terminal.

main.cpp
--------
#include <iostream>

// Change needs_it_support so that it returns support:
bool needs_it_support() {
  
  bool support;
  
  std::cout << "Hello. IT. Have you tried turning it off and on again? Enter 1 for yes, 0 for no.\n";
  std::cin >> support;
  return support;
  
}

int main() {
  
  // Change the following line to print the function result:
 std::cout << needs_it_support();
  
}

==================================================================================================================================================================

* How Return Values Work
------------------------
When functions have a return type other than void, the function has two new requirements:

	. There must be a value returned from the function.

	. The return value must be the same type as the function’s return type.

But where does the return value get returned to?

It gets returned to the place where the function is called. For example, if you have the following function:

std::string feed_the_cat() {
 
  return "Cat is fed!";
 
}

And then print the function call inside of main():

int main() {
 
  std::string cat_message = feed_the_cat();
  std::cout << cat_message;
 
}

The return value of the function is what gets printed to the terminal.

==================================================================================================================================================================



































































































































